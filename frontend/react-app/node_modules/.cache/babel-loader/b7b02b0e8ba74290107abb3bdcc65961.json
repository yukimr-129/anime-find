{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useCallback, useEffect } from \"react\";\nimport { useRecoilState } from \"recoil\";\nimport { client } from \"lib/api/client\";\nimport { AnimeLists } from \"store/AnimeLists\";\nimport { ApiKeyValue } from \"store/ApiKeyValue\";\nimport { HasMore } from \"store/loding/HasMore\";\nimport { useMessage } from \"./message/useMessage\";\nimport { LoadPage } from \"store/LoadPage\";\nexport const useNextAnimes = page => {\n  _s();\n\n  const [isFetching, setIsFetching] = useState(false);\n  const [isLoading, setIsLoding] = useState(false);\n  const [hasMore, setHasMore] = useRecoilState(HasMore);\n  const [apiKeyValue, setApiKeyValue] = useRecoilState(ApiKeyValue);\n  const [animeLists, setAnimeLists] = useRecoilState(AnimeLists);\n  const [loadPage, setLoadPage] = useRecoilState(LoadPage);\n  const {\n    showMessage\n  } = useMessage(); // const getNextAnimes = useCallback(async(page: number) => {\n  //     try {\n  //         setIsFetching(true);\n  //         const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`\n  //         const getanime = await client.get('/api/annicts/search', {\n  //             params: {\n  //                 filter_season,\n  //                 page\n  //             }\n  //         })\n  //         const animeDate: AnnictApiType[] = getanime.data.works\n  //         console.log(getanime);\n  //         if (animeDate.length < 1) {\n  //             setHasMore(false);\n  //             return;\n  //         }\n  //         const distinctList = new Set([...animeLists, ...animeDate])\n  //         // const list: AnnictApiType[] = [...distinctList]\n  //         setAnimeLists([...distinctList])\n  //         console.log(animeLists);\n  //         console.log(getanime);\n  //     } catch (error) {\n  //         showMessage({title: 'アニメ一覧の取得に失敗しました', status: \"error\"})\n  //     } finally {\n  //         setIsFetching(false);\n  //     }    \n  // },[animeLists])\n\n  const getNextAnimes = useCallback(async () => {\n    console.log(page);\n\n    try {\n      setIsFetching(true);\n      setIsLoding(true);\n      const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`;\n      const getanime = await client.get('/api/annicts/search', {\n        params: {\n          filter_season,\n          page\n        }\n      });\n      const animeDate = getanime.data.works; // for (const data of animeDate) {\n      //     console.log(data);\n      // }\n      // const data = animeDate.map((data) => {\n      // })\n\n      const distinctData = animeDate.filter((data, index, self) => {\n        const ids = self.map(data => data['id']);\n\n        if (ids.indexOf(data.id) === index) {\n          return item;\n        }\n      });\n      const array = [{\n        name: 'orange',\n        price: 150\n      }, {\n        name: 'apple',\n        price: 160\n      }, {\n        name: 'banana',\n        price: 200\n      }, {\n        name: 'apple',\n        price: 160\n      }, {\n        name: 'grape',\n        price: 300\n      }, {\n        name: 'orange',\n        price: 150\n      }];\n      const result = array.filter((item, index, self) => {\n        // name だけをリスト化する\n        const nameList = self.map(item => item['name']); // 重複を削除する\n\n        if (nameList.indexOf(item.name) === index) {\n          return item;\n        }\n      });\n      console.log(result);\n\n      if (animeDate.length < 1) {\n        setHasMore(false);\n      }\n\n      const distinctList = new Set([...animeLists, ...animeDate]); // const list: AnnictApiType[] = [...distinctList]\n\n      setAnimeLists(prevList => {\n        return [...new Set([...prevList, ...animeDate])];\n      });\n      setIsLoding(false);\n      console.log(animeLists);\n    } catch (error) {\n      showMessage({\n        title: 'アニメ一覧の取得に失敗しました',\n        status: \"error\"\n      });\n    } finally {\n      setIsFetching(false);\n    }\n  }, [loadPage]);\n  useEffect(() => {\n    let isMounted = true;\n    isMounted && getNextAnimes();\n    return () => {\n      isMounted = false;\n    };\n  }, [loadPage]);\n  return {\n    getNextAnimes,\n    animeLists,\n    isLoading\n  };\n};\n\n_s(useNextAnimes, \"ClDjClcnwpeqKEZMPfgqnKi81Ac=\", false, function () {\n  return [useRecoilState, useRecoilState, useRecoilState, useRecoilState, useMessage];\n});","map":{"version":3,"sources":["/usr/src/app/react-app/src/customHooks/useNextAnimes.ts"],"names":["useState","useCallback","useEffect","useRecoilState","client","AnimeLists","ApiKeyValue","HasMore","useMessage","LoadPage","useNextAnimes","page","isFetching","setIsFetching","isLoading","setIsLoding","hasMore","setHasMore","apiKeyValue","setApiKeyValue","animeLists","setAnimeLists","loadPage","setLoadPage","showMessage","getNextAnimes","console","log","filter_season","year","cour","getanime","get","params","animeDate","data","works","distinctData","filter","index","self","ids","map","indexOf","id","item","array","name","price","result","nameList","length","distinctList","Set","prevList","error","title","status","isMounted"],"mappings":"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","sourcesContent":["import { useState, useCallback, useEffect } from \"react\";\n\nimport { useRecoilState } from \"recoil\";\n\nimport { client } from \"lib/api/client\";\nimport { AnimeLists } from \"store/AnimeLists\";\nimport { ApiKeyValue } from \"store/ApiKeyValue\";\nimport { HasMore } from \"store/loding/HasMore\";\nimport { AnnictApiType } from \"types/api/AnnictApiType\";\nimport { useMessage } from \"./message/useMessage\";\nimport { LoadPage } from \"store/LoadPage\";\n\n\ntype NextAnimes = (page: number) => {\n    getNextAnimes: () => void;\n    // isFetching: boolean;\n    isLoading: boolean;\n    animeLists: AnnictApiType[];\n}\n\nexport const useNextAnimes: NextAnimes = (page: number) => {\n    const [ isFetching, setIsFetching ]  = useState(false);\n    const [ isLoading, setIsLoding ]  = useState(false);\n    const [ hasMore, setHasMore ] = useRecoilState(HasMore)\n    const [ apiKeyValue, setApiKeyValue ] = useRecoilState(ApiKeyValue)\n    const [ animeLists, setAnimeLists ] = useRecoilState(AnimeLists)\n    const [ loadPage, setLoadPage ] = useRecoilState(LoadPage)\n    const { showMessage } = useMessage()\n\n    // const getNextAnimes = useCallback(async(page: number) => {\n    //     try {\n    //         setIsFetching(true);\n    //         const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`\n    //         const getanime = await client.get('/api/annicts/search', {\n    //             params: {\n    //                 filter_season,\n    //                 page\n    //             }\n    //         })\n    //         const animeDate: AnnictApiType[] = getanime.data.works\n    //         console.log(getanime);\n            \n    //         if (animeDate.length < 1) {\n    //             setHasMore(false);\n    //             return;\n    //         }\n    //         const distinctList = new Set([...animeLists, ...animeDate])\n    //         // const list: AnnictApiType[] = [...distinctList]\n            \n    //         setAnimeLists([...distinctList])\n    //         console.log(animeLists);\n    //         console.log(getanime);\n    //     } catch (error) {\n    //         showMessage({title: 'アニメ一覧の取得に失敗しました', status: \"error\"})\n    //     } finally {\n    //         setIsFetching(false);\n    //     }    \n    // },[animeLists])\n    const getNextAnimes = useCallback(async() => {\n        console.log(page);\n        \n        try {\n            setIsFetching(true);\n            setIsLoding(true)\n            const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`\n            const getanime = await client.get('/api/annicts/search', {\n                params: {\n                    filter_season,\n                    page\n                }\n            })\n            const animeDate: AnnictApiType[] = getanime.data.works\n            // for (const data of animeDate) {\n            //     console.log(data);\n            // }\n            // const data = animeDate.map((data) => {\n\n            // })\n\n            const distinctData = animeDate.filter((data, index, self) => {\n                const ids = self.map(data => data['id'])\n\n                if(ids.indexOf(data.id) === index){\n                    return item;\n                }\n            })\n\n            const array = [{ name: 'orange', price: 150 }, { name: 'apple', price: 160 }, { name: 'banana', price: 200 }, { name: 'apple', price: 160 }, { name: 'grape', price: 300 }, { name: 'orange', price: 150 }];\n \n            const result = array.filter((item, index, self) => {\n            // name だけをリスト化する\n                const nameList = self.map(item => item['name']);\n                // 重複を削除する\n                if (nameList.indexOf(item.name) === index) {\n                    return item;\n                }\n            });\n            console.log(result);\n            \n\n            \n            \n            if (animeDate.length < 1) {\n                setHasMore(false);\n            }\n\n            const distinctList = new Set([...animeLists, ...animeDate])\n            // const list: AnnictApiType[] = [...distinctList]\n            \n            setAnimeLists((prevList) => {\n                return [...new Set([...prevList, ...animeDate])]\n            })\n            setIsLoding(false)\n            console.log(animeLists);\n        } catch (error) {\n            showMessage({title: 'アニメ一覧の取得に失敗しました', status: \"error\"})\n        } finally {\n            setIsFetching(false);\n        }    \n    },[loadPage])\n\n    useEffect(() => {\n        let isMounted = true\n        isMounted && getNextAnimes()\n        return () => {\n            isMounted = false\n        }\n    }, [loadPage])\n\n    return { getNextAnimes, animeLists, isLoading }\n}\n\n"]},"metadata":{},"sourceType":"module"}