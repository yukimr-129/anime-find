{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useCallback, useEffect } from \"react\";\nimport { useRecoilState, useRecoilValue, useSetRecoilState } from \"recoil\";\nimport { client } from \"lib/api/client\";\nimport { AnimeLists } from \"store/AnimeLists\";\nimport { ApiKeyValue } from \"store/ApiKeyValue\";\nimport { HasMore } from \"store/loding/HasMore\";\nimport { useMessage } from \"./message/useMessage\";\nimport { LoadPage } from \"store/LoadPage\";\nexport const useNextAnimes = page => {\n  _s();\n\n  const [isLoading, setIsLoding] = useState(false);\n  const [animeLists, setAnimeLists] = useRecoilState(AnimeLists);\n  const setHasMore = useSetRecoilState(HasMore);\n  const apiKeyValue = useRecoilValue(ApiKeyValue);\n  const loadPage = useRecoilValue(LoadPage);\n  const {\n    showMessage\n  } = useMessage();\n  const getNextAnimes = useCallback(async () => {\n    try {\n      setIsLoding(true);\n      const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`;\n      const res = await client.get('/annicts/search', {\n        params: {\n          filter_season,\n          page\n        }\n      });\n\n      if (res.status === 200) {\n        const animeDate = res.data.works;\n\n        if (animeDate.length < 1) {\n          setHasMore(false);\n        } //重複データ削除\n\n\n        const dataList = [...animeLists, ...animeDate];\n        let map = new Map(dataList.map(data => [data.id, data]));\n        const distinctDataList = Array.from(map.values());\n        setAnimeLists(distinctDataList);\n        setIsLoding(false);\n      } else {}\n    } catch (error) {\n      showMessage({\n        title: 'アニメ一覧の取得に失敗しました',\n        status: \"error\"\n      });\n    }\n  }, [loadPage]);\n  useEffect(() => {\n    let isMounted = true;\n    isMounted && getNextAnimes();\n    return () => {\n      isMounted = false;\n    };\n  }, [loadPage]);\n  return {\n    animeLists,\n    isLoading\n  };\n};\n\n_s(useNextAnimes, \"mD4hn+/gll+0wNd9VDOMqREcLB0=\", false, function () {\n  return [useRecoilState, useSetRecoilState, useRecoilValue, useRecoilValue, useMessage];\n});","map":{"version":3,"sources":["/usr/src/app/react-app/src/customHooks/useNextAnimes.ts"],"names":["useState","useCallback","useEffect","useRecoilState","useRecoilValue","useSetRecoilState","client","AnimeLists","ApiKeyValue","HasMore","useMessage","LoadPage","useNextAnimes","page","isLoading","setIsLoding","animeLists","setAnimeLists","setHasMore","apiKeyValue","loadPage","showMessage","getNextAnimes","filter_season","year","cour","res","get","params","status","animeDate","data","works","length","dataList","map","Map","id","distinctDataList","Array","from","values","error","title","isMounted"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,WAAnB,EAAgCC,SAAhC,QAAiD,OAAjD;AAEA,SAASC,cAAT,EAAyBC,cAAzB,EAAyCC,iBAAzC,QAAkE,QAAlE;AAEA,SAASC,MAAT,QAAuB,gBAAvB;AACA,SAASC,UAAT,QAA2B,kBAA3B;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,OAAT,QAAwB,sBAAxB;AAEA,SAASC,UAAT,QAA2B,sBAA3B;AACA,SAASC,QAAT,QAAyB,gBAAzB;AAQA,OAAO,MAAMC,aAAyB,GAAIC,IAAD,IAAkB;AAAA;;AACvD,QAAM,CAAEC,SAAF,EAAaC,WAAb,IAA8Bf,QAAQ,CAAC,KAAD,CAA5C;AACA,QAAM,CAAEgB,UAAF,EAAcC,aAAd,IAAgCd,cAAc,CAACI,UAAD,CAApD;AACA,QAAMW,UAAU,GAAGb,iBAAiB,CAACI,OAAD,CAApC;AACA,QAAMU,WAAW,GAAGf,cAAc,CAACI,WAAD,CAAlC;AACA,QAAMY,QAAQ,GAAGhB,cAAc,CAACO,QAAD,CAA/B;AACA,QAAM;AAAEU,IAAAA;AAAF,MAAkBX,UAAU,EAAlC;AAEA,QAAMY,aAAa,GAAGrB,WAAW,CAAC,YAAW;AACzC,QAAI;AACAc,MAAAA,WAAW,CAAC,IAAD,CAAX;AACA,YAAMQ,aAAa,GAAI,GAAEJ,WAAW,CAACK,IAAK,IAAGL,WAAW,CAACM,IAAK,EAA9D;AACA,YAAMC,GAAG,GAAG,MAAMpB,MAAM,CAACqB,GAAP,CAAW,iBAAX,EAA8B;AAC5CC,QAAAA,MAAM,EAAE;AACJL,UAAAA,aADI;AAEJV,UAAAA;AAFI;AADoC,OAA9B,CAAlB;;AAOA,UAAIa,GAAG,CAACG,MAAJ,KAAe,GAAnB,EAAwB;AACpB,cAAMC,SAA0B,GAAGJ,GAAG,CAACK,IAAJ,CAASC,KAA5C;;AACA,YAAIF,SAAS,CAACG,MAAV,GAAmB,CAAvB,EAA0B;AACtBf,UAAAA,UAAU,CAAC,KAAD,CAAV;AACH,SAJmB,CAMpB;;;AACA,cAAMgB,QAAQ,GAAG,CAAC,GAAGlB,UAAJ,EAAgB,GAAGc,SAAnB,CAAjB;AAEA,YAAIK,GAAG,GAAG,IAAIC,GAAJ,CAAQF,QAAQ,CAACC,GAAT,CAAsCJ,IAAI,IAAI,CAACA,IAAI,CAACM,EAAN,EAAUN,IAAV,CAA9C,CAAR,CAAV;AACA,cAAMO,gBAAgB,GAAGC,KAAK,CAACC,IAAN,CAAWL,GAAG,CAACM,MAAJ,EAAX,CAAzB;AAEAxB,QAAAA,aAAa,CAACqB,gBAAD,CAAb;AACAvB,QAAAA,WAAW,CAAC,KAAD,CAAX;AACH,OAdD,MAcO,CAEN;AACJ,KA3BD,CA2BE,OAAO2B,KAAP,EAAc;AACZrB,MAAAA,WAAW,CAAC;AAACsB,QAAAA,KAAK,EAAE,iBAAR;AAA2Bd,QAAAA,MAAM,EAAE;AAAnC,OAAD,CAAX;AACH;AACJ,GA/BgC,EA+B/B,CAACT,QAAD,CA/B+B,CAAjC;AAiCAlB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI0C,SAAS,GAAG,IAAhB;AACAA,IAAAA,SAAS,IAAItB,aAAa,EAA1B;AACA,WAAO,MAAM;AACTsB,MAAAA,SAAS,GAAG,KAAZ;AACH,KAFD;AAGH,GANQ,EAMN,CAACxB,QAAD,CANM,CAAT;AAQA,SAAO;AAAEJ,IAAAA,UAAF;AAAcF,IAAAA;AAAd,GAAP;AACH,CAlDM;;GAAMF,a;UAE6BT,c,EACnBE,iB,EACCD,c,EACHA,c,EACOM,U","sourcesContent":["import { useState, useCallback, useEffect } from \"react\";\n\nimport { useRecoilState, useRecoilValue, useSetRecoilState } from \"recoil\";\n\nimport { client } from \"lib/api/client\";\nimport { AnimeLists } from \"store/AnimeLists\";\nimport { ApiKeyValue } from \"store/ApiKeyValue\";\nimport { HasMore } from \"store/loding/HasMore\";\nimport { AnnictApiType } from \"types/api/AnnictApiType\";\nimport { useMessage } from \"./message/useMessage\";\nimport { LoadPage } from \"store/LoadPage\";\n\n\ntype NextAnimes = (page: number) => {\n    isLoading: boolean;\n    animeLists: AnnictApiType[];\n}\n\nexport const useNextAnimes: NextAnimes = (page: number) => {\n    const [ isLoading, setIsLoding ]  = useState(false);\n    const [ animeLists, setAnimeLists ] = useRecoilState(AnimeLists)\n    const setHasMore = useSetRecoilState(HasMore)\n    const apiKeyValue = useRecoilValue(ApiKeyValue)\n    const loadPage = useRecoilValue(LoadPage)\n    const { showMessage } = useMessage()\n\n    const getNextAnimes = useCallback(async() => {        \n        try {\n            setIsLoding(true)\n            const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`\n            const res = await client.get('/annicts/search', {\n                params: {\n                    filter_season,\n                    page\n                }\n            })\n\n            if (res.status === 200) {\n                const animeDate: AnnictApiType[] = res.data.works\n                if (animeDate.length < 1) {\n                    setHasMore(false);\n                }\n                \n                //重複データ削除\n                const dataList = [...animeLists, ...animeDate]            \n                \n                let map = new Map(dataList.map<[number, AnnictApiType]>(data => [data.id, data]));\n                const distinctDataList = Array.from(map.values())\n    \n                setAnimeLists(distinctDataList)\n                setIsLoding(false) \n            } else {\n                \n            }\n        } catch (error) {\n            showMessage({title: 'アニメ一覧の取得に失敗しました', status: \"error\"})\n        }\n    },[loadPage])\n\n    useEffect(() => {\n        let isMounted = true\n        isMounted && getNextAnimes()\n        return () => {\n            isMounted = false\n        }\n    }, [loadPage])\n\n    return { animeLists, isLoading }\n}\n\n"]},"metadata":{},"sourceType":"module"}