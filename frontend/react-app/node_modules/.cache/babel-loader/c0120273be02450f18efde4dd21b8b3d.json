{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState } from 'react';\nimport { useRecoilState } from 'recoil';\nimport { client } from \"../lib/api/client\";\nimport { ApiKeyValue } from '../store/ApiKeyValue';\nimport { useMessage } from './message/useMessage';\nimport { AnimeLists } from '../store/AnimeLists';\nimport { HasMore } from 'store/loding/HasMore';\nexport const useAnimeApiSearch = () => {\n  _s();\n\n  const [isFetching, setIsFetching] = useState(false); // const [ hasMore, setHasMore ] = useState(true)\n\n  const [hasMore, setHasMore] = useRecoilState(HasMore);\n  const [apiKeyValue, setApiKeyValue] = useRecoilState(ApiKeyValue);\n  const [animeLists, setAnimeLists] = useRecoilState(AnimeLists);\n  const {\n    showMessage\n  } = useMessage(); //初回表示リスト取得\n\n  const getAnimes = useCallback(async page => {\n    try {\n      // setIsFetching(true);\n      // console.log(page);\n      const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`;\n      const getanime = await client.get('/api/annicts/search', {\n        params: {\n          filter_season,\n          page\n        }\n      });\n      const animeDate = getanime.data.works; // if (animeDate.length < 1) {\n      //     setHasMore(false);\n      //     return;\n      // }\n      // setAnimeLists(animeDate)\n\n      console.log(animeDate);\n      setAnimeLists(animeDate); //リスト再取得時にInfiniteScrollの値初期化\n\n      setHasMore(true);\n    } catch (error) {\n      showMessage({\n        title: 'アニメ一覧の取得に失敗しました',\n        status: \"error\"\n      });\n    } // finally {\n    //     setIsFetching(false);\n    // }\n\n  }, [animeLists, apiKeyValue]);\n  const getNextAnimes = useCallback(async page => {\n    try {\n      setIsFetching(true);\n      const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`;\n      const getanime = await client.get('/api/annicts/search', {\n        params: {\n          filter_season,\n          page\n        }\n      });\n      const animeDate = getanime.data.works;\n      console.log(getanime);\n\n      if (animeDate.length < 1) {\n        setHasMore(false);\n        return;\n      }\n\n      const distinctList = new Set([...animeLists, ...animeDate]); // const rep = Array.from(s)\n\n      const list = [...distinctList]; // console.log(rep);\n\n      setAnimeLists([...list]);\n      console.log(animeLists);\n      console.log(getanime);\n    } catch (error) {\n      showMessage({\n        title: 'アニメ一覧の取得に失敗しました',\n        status: \"error\"\n      });\n    } finally {\n      setIsFetching(false);\n    }\n  }, [animeLists]); // 初回レンダリング時、検索時最初のページ取得\n  // useEffect(() => {\n  //     getAnimes(1) \n  //     console.log(animeLists); \n  //     console.log(\"実行\"); \n  // }, [apiKeyValue])\n\n  return {\n    animeLists,\n    hasMore,\n    isFetching,\n    getAnimes\n  };\n};\n\n_s(useAnimeApiSearch, \"LxLNRLXyTm8ipIxi58vG0bzERXY=\", false, function () {\n  return [useRecoilState, useRecoilState, useRecoilState, useMessage];\n});","map":{"version":3,"sources":["/usr/src/app/react-app/src/customHooks/useAnimeApiSearch.ts"],"names":["useCallback","useState","useRecoilState","client","ApiKeyValue","useMessage","AnimeLists","HasMore","useAnimeApiSearch","isFetching","setIsFetching","hasMore","setHasMore","apiKeyValue","setApiKeyValue","animeLists","setAnimeLists","showMessage","getAnimes","page","filter_season","year","cour","getanime","get","params","animeDate","data","works","console","log","error","title","status","getNextAnimes","length","distinctList","Set","list"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react'\nimport { useRecoilState, useRecoilValue } from 'recoil'\n\nimport { client } from \"../lib/api/client\"\nimport { ApiKeyValue } from '../store/ApiKeyValue'\nimport { useMessage } from './message/useMessage'\nimport { AnnictApiType } from '../types/api/AnnictApiType'\nimport { AnimeLists } from '../store/AnimeLists'\nimport { HasMore } from 'store/loding/HasMore'\n\ntype AnimeApiSearch = () => {\n        animeLists: AnnictApiType[];\n        getAnimes: (page: number) => void;\n        getNextAnimes: (page: number) => void;\n        hasMore: boolean;\n        isFetching: boolean;\n}\n\nexport const useAnimeApiSearch: AnimeApiSearch = () => {\n    const [ isFetching, setIsFetching]  = useState(false);\n    // const [ hasMore, setHasMore ] = useState(true)\n    const [ hasMore, setHasMore ] = useRecoilState(HasMore)\n    const [ apiKeyValue, setApiKeyValue ] = useRecoilState(ApiKeyValue)\n    const [ animeLists, setAnimeLists ] = useRecoilState(AnimeLists)\n    const { showMessage } = useMessage()\n        \n        //初回表示リスト取得\n        const getAnimes = useCallback(async(page: number) => {\n            try {\n                // setIsFetching(true);\n                // console.log(page);\n                \n                const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`\n                const getanime = await client.get('/api/annicts/search', {\n                    params: {\n                        filter_season,\n                        page\n                    }\n                })\n                \n                const animeDate: AnnictApiType[] = getanime.data.works\n                // if (animeDate.length < 1) {\n                //     setHasMore(false);\n                //     return;\n                // }\n                // setAnimeLists(animeDate)\n                console.log(animeDate);\n                \n                setAnimeLists(animeDate)\n\n                //リスト再取得時にInfiniteScrollの値初期化\n                setHasMore(true)\n            } catch (error) {\n                showMessage({title: 'アニメ一覧の取得に失敗しました', status: \"error\"})\n            } \n            // finally {\n            //     setIsFetching(false);\n            // }\n        }, [animeLists, apiKeyValue])\n\n        const getNextAnimes = useCallback(async(page: number) => {\n            try {\n                setIsFetching(true);\n                const filter_season = `${apiKeyValue.year}-${apiKeyValue.cour}`\n                const getanime = await client.get('/api/annicts/search', {\n                    params: {\n                        filter_season,\n                        page\n                    }\n                })\n                const animeDate: AnnictApiType[] = getanime.data.works\n                console.log(getanime);\n                \n                if (animeDate.length < 1) {\n                    setHasMore(false);\n                    return;\n                }\n                const distinctList = new Set([...animeLists, ...animeDate])\n                // const rep = Array.from(s)\n                const list: AnnictApiType[] = [...distinctList]\n                \n                // console.log(rep);\n                \n                setAnimeLists([...list])\n                console.log(animeLists);\n                console.log(getanime);\n            } catch (error) {\n                showMessage({title: 'アニメ一覧の取得に失敗しました', status: \"error\"})\n            } finally {\n                setIsFetching(false);\n            }    \n        },[animeLists])\n\n        // 初回レンダリング時、検索時最初のページ取得\n        // useEffect(() => {\n        //     getAnimes(1) \n        //     console.log(animeLists); \n        //     console.log(\"実行\"); \n        // }, [apiKeyValue])\n\n    return { animeLists, hasMore, isFetching, getAnimes }\n}"]},"metadata":{},"sourceType":"module"}